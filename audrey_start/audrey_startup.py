#! /usr/bin/env python
'''
Audrey Startup (AS)

Invoked at instance launch to interface with the Config Server (CS)

For prototype end to end testing this file needs to be installed
at: /usr/bin/audrey

Algorithim:
    Get CF info
    Loop:
        Get and validate required configuration from CS
        Configure system using required configuration
        Get and validate provides parameters from CS
        Gather provided parameter data from system
        Put provided parameter data to CS
    if not done then goto Loop

'''

import base64
import httplib2
import syslog
from subprocess import Popen, PIPE
import urllib

LOG = '/var/log/audrey.log'
PUPPET_ROOT = '/usr/share/puppet/cloud_engine/audrey_puppet'
PUPPET_YAML_FILE = str(PUPPET_ROOT) + '/nodes/default'
PUPPET_EXT_NODE = str(PUPPET_ROOT) + '/node'

CLASS_TAG = '|classes'
PARAM_TAG = '|parameters'

# When running on condor-cloud, the Config Server (CS) contact
# information will be stored in the smbios.
# These are the dmi files where the smbios information is stored.
CONDORCLOUD_CS_ADDR='/sys/devices/virtual/dmi/id/sys_vendor'
CONDORCLOUD_CS_UUID='/sys/devices/virtual/dmi/id/product_name'

# When running on RHEV-m, the Config Server (CS) contact
# information will be stored in a file built into the image
# and the UUID will be stored in the smbios.
# These are the dmi files where the smbios information is stored.
RHEV_CS_ADDR='/opt/redhat/cloudengine/rhevm_config_server'
RHEV_CS_UUID='/sys/devices/virtual/dmi/id/product_uuid'

#
# Error Handling methods:
#
class ASError(Exception):
    '''
    Some sort of error occurred. The exact cause of the error should
    have been logged. So, this just indicates that something is wrong.
    '''
    pass

def _raise_ASError(err_msg):
    '''
    Post an error message to syslog and raise ASError
    '''
    syslog.syslog(syslog.LOG_ERR, err_msg)
    raise ASError(err_msg)

class _run_cmd_return_subproc():
    '''
    Used to pass return code to caller if no subprocess object
    is generated by Popen() due to an error.
    '''
    returncode = 127

#
# Misc. Supporting Methods
#
def _run_cmd(cmd):
    '''
    Description:
        Run a command given by a dictionary, check for stderr output,
        return code.

        To check the return code catch SystemExit then examine:
        ret['subproc'].returncode.

    Input:

        cmd - a list containing the command to execute.
            e.g.: cmd = ['ls', '/tmp']

    Returns:

        ret - a dictionary upon return contains the keys:
            'subproc', 'err', 'out'

        ret['subproc'].returncode = subprocess return code
        ret['err'] = command errors string.
        ret['out'] = command out list.

    Example:

        cmd = ['ls', '/tmp']
        ret = _run_cmd(cmd)

        ret.keys()
        ['subproc', 'err', 'out']
        ret['subproc'].returncode
        0
        ret['err']
        ''
        ret['out']

    '''

    pfail = _run_cmd_return_subproc()

    # Return dictionary to contain keys: 'cmd', 'subproc', 'err', 'out'
    ret = {'subproc' : None, 'err' : '' , 'out' : ''}

    try:
        ret['subproc'] = Popen(cmd, stdout=PIPE, stderr=PIPE)

    # unable to find command will result in an OSError
    except OSError, err:
        if not ret['subproc']:
            ret['subproc'] = pfail

        ret['subproc'].returncode = 127 # command not found
        ret['err'] = str(err)
        return ret

    # fill ret['out'] with stdout and ret['err'] with stderr
    ret.update(zip(['out', 'err'], ret['subproc'].communicate()))

    return ret

def _run_pipe_cmd(cmd1, cmd2):
    '''
    Description:
        Run one command piped into another. Commands are given as
        dictionaries, check for stderr output, return code.

        To check the return code catch SystemExit then examine:
        ret['subproc'].returncode.

        That is this routine can be used to execute a command
        of the form:

    Input:

        cmd1 - a list containing the command to execute.
            e.g.: cmd = ['ls', '/tmp']

        cmd2 - a list containing the command to pipe the output
            of cmd1 to.
            e.g.: cmd = ['grep', 'a_file']

    Returns:

        ret - a dictionary upon return contains the keys:
            'subproc', 'err', 'out'

        ret['subproc'].returncode = subprocess return code
        ret['err'] = command errors string.
        ret['out'] = command out list.

    Example:

        cmd1 = ['ls', '/tmp']
        cmd2 = ['grep', 'a_file']
        ret = _run_pipe_cmd(cmd1, cmd2)

        ret.keys()
        ['subproc', 'err', 'out']
        ret['subproc'].returncode
        0
        ret['err']
        ''
        ret['out']

    '''

    # Return dictionary to contain keys: 'cmd', 'subproc', 'err', 'out'
    ret = {'subproc' : None, 'err' : '' , 'out' : ''}

    p1 = None
    p2 = None
    pfail = _run_cmd_return_subproc()

    # Execute the first command:
    try:
        p1 = Popen(cmd1, stdout=PIPE)
        p2 = Popen(cmd2, stdin=p1.stdout, stdout=PIPE )
        p1.stdout.close()

        # fill ret['out'] with stdout and ret['err'] with stderr
        # ret.update(zip(['out', 'err'], ret['subproc'].communicate()[0]))
        ret.update(zip(['out', 'err'], p2.communicate()))
        ret['subproc'] = p2

    # unable to find command will result in an OSError
    except OSError, err:
        if p2:
            ret['subproc'] = p2
        elif p1:
            ret['subproc'] = p1
        else:
            ret['subproc'] = pfail

        ret['subproc'].returncode = 127 # command not found
        ret['err'] = str(err)
        return ret

    return ret

#
# Methods used to parse the CS<->AS text based API
#
def _common_validate_message(src):
    '''
    Perform validation of the text message sent from the Config Server.
    '''

    if not src.startswith('|') or not src.endswith('|'):
        raise ASError(('Invalid start and end characters: %s') % (src))

def _parse_require_config(src):
    '''
    Description:
        Parse the required config text message sent from the Config Server.

    Input:
        The required config string obtained from the Config Server.
    The delimiters will be an | and an &

        Two tags will mark the sections of the data. Each tag will be precede
        with an |:

        |classes
        |parameters

        To ensure all the data was received the entire string will be
        terminated with an "|".

        The string "|classes" will precede the class names. I don't think
        the class names need to be base64 encoded.

        The string "|parameters" will precede the parameter parameter
        names&<b64 encoded values>.

    This will be a continuous text string (no CR or New Line).

        Format:

        |classes&<c1>&<c2>...&<cN>
            |parameters|name1&<b64val>|name2&<b64val>...|nameN&<b64v>|

        e.g.:
        |classes&ssh::server&apache2::common
            |parameters|ssh_port&<b64/22>|apache_port&<b64/8081>|

    Returns:
        - a list of classes
        - a name&value list of parameters.
    '''

    _common_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no required config needed.
        return [''], ['']

    if src.find('|classes') != 0:
        _raise_ASError(('|classes not the first tag found. %s') % (src))

    if src.find('|parameters') <= 0:
        _raise_ASError(('|parameters not found after |classes. %s')
             % (src))

    params_str = src[src.find('|parameters'):len(src)-1]
    classes_str = src[src.find('|classes'):src.find('|parameters')]

    return params_str[len('|parameters')+1:].split('|'), \
        classes_str[len('|classes')+1:].split('&')

def generate_yaml(src, yaml_file=PUPPET_YAML_FILE):
    '''
    Description:
        Generate the Puppet input YAML file.
        Uses _parse_require_config()

    Input:
        The required config string obtained from the Config Server.

        Allow for an alternate puppet YAML file for unit testing.

    Output:
        The Puppet YAML file.
            The YAML file format:
                ---
                parameters:
                  <p1>: <v1>
                  <p2>: <v2>
                ...
                <pN>: <vN>
                classes:
                - <name1::type1>
                - <name2::type2>
                ...
                - <nameN::typeN>

            e.g.:
                ---
                parameters:
                  ssh_port: 22
                  apache_port: 8081
                classes:
                - ssh::server
                - apache2::common

    Returns:
        False - If the Puppet YAML file was not created. This could happen
                if no required parametes or classes were provided.
        True  - If the Puppet YAML file was created.
    '''
    syslog.syslog('Invoked generate_yaml()')

    params_list, classes_list = _parse_require_config(src)

    # If both classes or parameters are missing treat as no required
    # configuration parameters are needed. Simply return False
    if params_list == [''] and classes_list == ['']:
        return False

    # If both classes or parameters are missing treat as an exception.
    if params_list == [''] or classes_list == ['']:
        _raise_ASError(('Missing classes or parameters. %s') % (src))

    with open(yaml_file, 'w') as yaml_fp:
        yaml_fp.writelines('---\n')
        yaml_fp.writelines('parameters:\n')
        try:
            for param in params_list:
                name_val = param.split('&')
                yaml_fp.writelines('  ' + str(name_val[0]))
                yaml_fp.writelines(': ' + \
                    base64.b64decode(str(name_val[1])) + '\n')
        except IndexError:
            _raise_ASError(('Missing parameter value. %s') % (src))

        yaml_fp.writelines('classes:\n')
        for classes in classes_list:
            yaml_fp.writelines('- ' + str(classes) + '\n')

    return True

def invoke_puppet():
    '''
    Description:
        Run the puppet command using the generated Puppet input YAML file.
        Uses _run_pipe_cmd()

    Input:
        The Puppet input YAML file must exist.

    Returns:
        None

    On Failure:
        Raise ASError

    '''
    syslog.syslog('Invoked invoke_puppet()')

    cmd1 = ['/bin/echo']

    cmd2 = ['/usr/bin/puppet', '--verbose', '--manifest', \
        str(PUPPET_ROOT) + '/manifests/defaults.pp', \
        '--modulepath', str(PUPPET_ROOT) + '/modules', \
        '--external_nodes', str(PUPPET_EXT_NODE), \
        '--node_terminus', 'exec', '--no-report', '>>', str(LOG), '2>&1']

    ret = _run_pipe_cmd(cmd1, cmd2)
    if ret['subproc'].returncode != 0:
        _raise_ASError(('Failed Puppet command: %s Error: %s') % \
            (str(cmd2), str(ret)))

def _get_system_info():
    '''
    Description:
        Get the system info to be used for generating this instances
        provides back to the Config Server.

        Currently utilizes Puppet's facter via a Python subprocess call.

    Input:
        None

    Returns:
        A dictionary of system info name/value pairs.

    '''

    cmd = ['/usr/bin/facter']
    ret = _run_cmd(cmd)
    if ret['subproc'].returncode != 0:
        _raise_ASError(('Failed command: %s Error: %s') % (str(cmd), str(ret)))

    facts = {}
    for fact in ret['out'].split('\n'):
        if fact: # Handle the new line at the end of the facter output
            name, val = fact.split(" => ")
            facts[ name ] = val.rstrip()

    return facts

def _parse_provides_params(src):
    '''
    Description:
        Parse the provides parameters text message sent from the
        Config Server.

    Input:
        The provides parameters string obtained from the Config Server.

        The delimiters will be an | and an &

        To ensure all the data was received the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Format:
        |name1&name2...&nameN|

        e.g.:
        |ipaddress&virtual|

    Returns:
        - a list of parameter names.
    '''

    _common_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no provides parameters requested.
        return ['']

    params_str = src[src.find('|')+1:len(src)-1]

    return params_str.split('&')

def generate_provides(src):
    '''
    Description:
        Generate the provides parameters list.
        Uses _parse_provides_params()

    Input:
        The provides parameters string obtained from the Config Server.

    Returns:
        A string to send back to the Config Server  with prifix
        'audrey_data='<url encoded return data>'

        The return portion will be delimited with an | and an &

        To ensure all the data is transmitted the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Data portion Format:
        |name1&val1|name2&val...|nameN$valN|

        e.g.:
        |ipaddress&<b64/10.118.46.205>|virtual&<b64/xenu>|

        The return string format:
        "audrey_data=<url encoded data portion>"


    '''
    syslog.syslog('Invoked generate_provides()')

    provides_dict = {}
    params_list = _parse_provides_params(src)

    system_info_dict = _get_system_info()

    for param in params_list:
        try:
            provides_dict.update( \
                {param:base64.b64encode(system_info_dict[param])})
        except KeyError:
            # A specified parameter is not found. Provide value ''
            provides_dict.update({param:''})


    # Create string to send to Config Server
    provides_list = ['']
    for key in provides_dict.keys():
        print str(key) + '&' + str(provides_dict[key])
        provides_list.append(str(key) + '&' + str(provides_dict[key]))
    provides_list.append('')

    return urllib.urlencode({'audrey_data':'|'.join(provides_list)})

#
# Classes and methods to perform the get and put to and from
# the Config Server (CS)
#
class HttpUnitTest(object):
    '''
    Description:
        When testing the http object does not exists. This class provides
        test methods that could be preformed when doing UNITTESTing.
    '''
    class HttpUnitTestResponse(object):
        '''
        Description:
            When testing the http object does not exists. This class
            provides the test method response that could be preformed
            when doing UNITTESTing.
        '''
        def __init__(self, status):
            self.status = status
        def status(self):
            return self.status

    # simple HTTP Response with 200 status code
    ok_response = HttpUnitTestResponse(200)

    def request(self, url, method='GET', body=None, headers=None):
        if method == 'GET' and url.find('/configs/') > -1:
            body = "|classes&c1&c2|parameters|param1&%s|param2&%s" % \
                    (base64.b64encode('value1'), base64.b64encode('value2'))
        elif (method == 'GET') and (url.find('/params/') > -1):
            body = "|param1&param2|"
        elif method == 'PUT' and url.find('/params/') > -1:
            body = ""
        return HttpUnitTest.ok_response, body

class CSClient(object):
    '''
    Description:
        Client interface to Config Server (CS)
    '''

    def __init__(self, UNITTEST=False):
        '''
        Description:
            Set initial state so it can be tracked. Valuable for
            testing and debugging.
        '''

        self.version = 0
        self.cloud_type = 'UNKNOWN'
        self.cs_addr = ''
        self.cs_port = ''
        self.cs_UUID = ''
        self.ec2_user_data_url = 'http://169.254.169.254/2009-04-04/user-data'
        self.config_serv = ''
        self.cs_params = ''
        self.cs_configs = ''

        #
        # What Cloud Backend?
        #
        # Read the file populated with Cloud back end type.
        # e.g.: CLOUD_TYPE="EC2"
        # NOTE: Currently only EC2 is supported.
        #
        self.cloud_info_file = '/etc/sysconfig/cloud-info'
        if not UNITTEST:
            try:
                with open(self.cloud_info_file, 'r') as f:
                    read_data = f.read()
            except IOError:
                _raise_ASError(('Failed accessing file %s') % \
                    (self.cloud_info_file))
        else:
            read_data = 'UNITTEST'

        self.http = httplib2.Http()

        #
        # Discover the Config Server access info.
        #
        cloud_type = read_data.upper()
        if 'EC2' in cloud_type:
            #
            # If on EC2 the user data will contain the Config Server
            # access info.
            #
            self.cloud_type = 'EC2'

            try:
                max_attempts = 5
                url = self.ec2_user_data_url
                headers = {'Accept': 'text/plain'}
                for attempt in range(1, max_attempts):
                    response, body = self._get(url, headers=headers)
                    if response.status == 200:
                        break
                if response.status != 200:
                    _raise_ASError('Max attempts to get EC2 user data \
                            exceeded.')

                self.config_serv = base64.b64decode(body)
                self.cs_addr, self.cs_port, self.cs_UUID = \
                        self.config_serv.split(':')
            except:
                _raise_ASError('Failed accessing EC2 user data.')

        elif 'CONDORCLOUD' in cloud_type:
            #
            # If on Condor Cloud, the user data will be in smbios
            # Uses the dmi files to access the stored smbios information.
            #
            self.cloud_type = 'CONDORCLOUD'
            try:
                # Sometimes the string http:// is appended to the
                # Condfig Server (CS) address:port.
                with open(CONDORCLOUD_CS_ADDR, 'r') as f:
                   self.cs_addr, self.cs_port = \
                       f.read()[:-1].lstrip('http://').split(':')

                with open(CONDORCLOUD_CS_UUID, 'r') as f:
                   self.cs_UUID = f.read()[:-1]

            except:
                _raise_ASError('Failed accessing Config Server data.')

        elif 'RHEV-M' in cloud_type:
            #
            # If on Condor Cloud, the user data will be in smbios
            # Uses the dmi files to access the stored smbios information.
            #
            self.cloud_type = 'RHEV-M'
            try:
                # Condfig Server (CS) address:port.
                with open(RHEV_CS_ADDR, 'r') as f:
                   self.cs_addr, self.cs_port = \
                       f.read()[:-1].split(':')

                with open(RHEV_CS_UUID, 'r') as f:
                   self.cs_UUID = f.read()[:-1]

            except:
                _raise_ASError('Failed accessing Config Server data.')

        elif 'UNITTEST' in cloud_type:
            #
            # For testing from UNITTEST
            # Populate self.cloud_info_file with UNITTEST
            #
            self.cloud_type = 'UNITTEST'
            self.config_serv = 'csAddr:csPort:csUUID'
            self.cs_addr = self.config_serv.split(':')[0]
            self.cs_port = self.config_serv.split(':')[1]
            self.cs_UUID = self.config_serv.split(':')[2]
            self.http = HttpUnitTest()

        else:
            _raise_ASError(('Unrecognized Cloud Type: %s') % \
                (self.cloud_type))

    def __str__(self):
        '''
        Description:
            Called by the str() function and by the print statement to
            produce the informal string representation of an object.
        '''
        return('<Instance of: %s\n' \
               'Version: %s\n' \
               'EC2 User Data URL: %s\n' \
               'Cloud Type: %s\n' \
               'Config Server: %s\n' \
               'Config Server Addr: %s\n' \
               'Config Server Port: %s\n' \
               'Config Server UUID: %s\n' \
               'Config Server Params: %s\n' \
               'Config Server Configs: %s\n' \
               'eot>' %
            (self.__class__.__name__,
            str(self.version),
            str(self.ec2_user_data_url),
            str(self.cloud_type),
            str(self.config_serv),
            str(self.cs_addr),
            str(self.cs_port),
            str(self.cs_UUID),
            str(self.cs_params),
            str(self.cs_configs)))

    def _get(self, url, headers=None):
        '''
        Description:
            Issue the http get to the the Config Server.
        '''
        return self.http.request(url, 'GET', headers=headers)

    def _put(self, url, body=None, headers=None):
        '''
        Description:
            Issue the http put to the the Config Server.
        '''
        return self.http.request(url, 'PUT', body=body, headers=headers)

    # Public interfaces
    def get_cs_configs(self):
        '''
        Description:
            get the required configuration from the Config Server.
        '''
        syslog.syslog('Invoked CSClient.get_cs_configs()')
        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/configs/' + str(self.version) + '/' + self.cs_UUID
        headers = {'Accept': 'text/plain'}

        response, body = self._get(url, headers=headers)
        return response.status, body

    def get_cs_params(self):
        '''
        Description:
            get the provides parameters from the Config Server.
        '''
        syslog.syslog('Invoked CSClient.get_cs_params()')
        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/params/' + str(self.version) + '/' + self.cs_UUID
        headers = {'Accept': 'text/plain'}

        response, body = self._get(url, headers=headers)
        return response.status, body

    def put_cs_params_values(self, params_values):
        '''
        Description:
            put the provides parameters to the Config Server.
        '''
        syslog.syslog('Invoked CSClient.put_cs_params_values()')
        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/params/' + str(self.version) + '/' + self.cs_UUID
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}

        response, body = self._put(url, body=params_values, headers=headers)
        return response.status, body

def audrey_script_main():
    '''
    Description:
        This script will be used on EC2 for configuring the running
        instance based on Cloud Engine configuration supplied at
        launch time in the user data.

        Config Server Status:
        200 HTTP OK - Success and no more data of this type
        202 HTTP Accepted - Success and more data of this type
        404 HTTP Not Found - This may be temporary so try again 
    '''
    syslog.syslog('Invoked audrey_script_main')

    finished = False
    not_found = False
    max_retry = 5

    while not finished:

        # Create the Client Object
        cs_client = CSClient()

        # Get the Required Configs from the Config Server
        config_status, configs = cs_client.get_cs_configs()

        # Configure the system with the provided Required Configs
        if (config_status == 200) or (config_status == 202):

            # Generate the YAML file using the provided required configs
            generate_yaml(configs)

            # Exercise Puppet using the generated YAML
            #
            # Exercise puppet to configure the system using the user
            # specified puppet input.
            #
            invoke_puppet()

        # Get the requested provides from the Config Server
        param_status, params = cs_client.get_cs_params()

        # Gather the values from the system for the requested provides
        if (param_status == 200) or (param_status == 202):

            # Generate the values for the requested provides parameters.
            params_values = generate_provides(params)

        else:

            # Return empty params values string even if the status code
            # is not success.
            # This will provide the Config Server with the IP Address
            # and UUID for this instance.
            params_values = "||"

        # Put the requested provides with values to the Config Server
        cs_client.put_cs_params_values(params_values)

        # Finish processing when the HTTP status from the get_cs_configs
        # and the get_cs_params both return 200
        finished = (config_status == 200) and (param_status == 200)


        # Retry a number of times if 404 HTTP Not Found is returned.
        if (config_status == 404) or (param_status == 404):
            max_retry -= 1
            if max_retry < 0:
                finished = True
        
if __name__ == '__main__':

    audrey_script_main()


