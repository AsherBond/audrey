#! /usr/bin/env python
'''
Audrey Startup (AS)

Invoked at instance launch to interface with the Config Server (CS)

For prototype end to end testing this file needs to be installed
at: /usr/bin/audrey

Algorithim:
    Get CF info
    Loop:
        Get and validate required configuration from CS
        Configure system using required configuration
        Get and validate provides parameters from CS
        Gather provided parameter data from system
        Put provided parameter data to CS
    if not done then goto Loop

'''

import base64
import os
import pycurl
import sys
import syslog
from subprocess import Popen, PIPE
import urllib

LOG = '/var/log/audrey.log'
PUPPET_ROOT = '/usr/share/puppet/cloud_engine/sshd'
PUPPET_YAML_FILE = str(PUPPET_ROOT) + '/nodes/default'
PUPPET_EXT_NODE = str(PUPPET_ROOT) + '/node'

CLASS_TAG = '|classes'
PARAM_TAG = '|parameters'

#
# Error Handling methods:
#
class ASError(Exception):
    '''
    Some sort of error occurred. The exact cause of the error should
    have been logged. So, this just indicates that something is wrong.
    '''
    pass

def _raise_ASError(err_msg):
    '''
    Post an error message to syslog and raise ASError
    '''
    syslog.syslog(syslog.LOG_ERR, err_msg)
    raise ASError(err_msg)

class _run_cmd_return_subproc():
    '''
    Used to pass return code to caller if no subprocess object
    is generated by Popen() due to an error.
    '''
    returncode = 127

#
# Misc. Supporting Methods
#
def _run_cmd(cmd):
    '''
    Description:
        Run a command given by a dictionary, check for stderr output,
        return code.

        To check the return code catch SystemExit then examine:
        ret['subproc'].returncode.

    Input:

        cmd - a list containing the command to execute.
            e.g.: cmd = ['ls', '/tmp']

    Returns:

        ret - a dictionary upon return contains the keys:
            'subproc', 'err', 'out'

        ret['subproc'].returncode = subprocess return code
        ret['err'] = command errors string.
        ret['out'] = command out list.

    Example:
        
        cmd = ['ls', '/tmp']
        ret = _run_cmd(cmd)

        ret.keys()
        ['subproc', 'err', 'out']
        ret['subproc'].returncode
        0
        ret['err']
        ''
        ret['out']

    '''

    p1 = None
    p2 = None
    pfail = _run_cmd_return_subproc()

    # Return dictionary to contain keys: 'cmd', 'subproc', 'err', 'out'
    ret = {'subproc' : None, 'err' : '' , 'out' : ''}

    try:
        ret['subproc'] = Popen(cmd, stdout=PIPE, stderr=PIPE)

    # unable to find command will result in an OSError
    except OSError, err:
        if not ret['subproc']:
            ret['subproc'] = pfail

        ret['subproc'].returncode = 127 # command not found
        ret['err'] = str(err)
        return ret

    # fill ret['out'] with stdout and ret['err'] with stderr
    ret.update(zip(['out', 'err'], ret['subproc'].communicate()))

    return ret

def _run_pipe_cmd(cmd1, cmd2):
    '''
    Description:
        Run one command piped into another. Commands are given as
        dictionaries, check for stderr output, return code.

        To check the return code catch SystemExit then examine:
        ret['subproc'].returncode.

        That is this routine can be used to execute a command
        of the form:

    Input:

        cmd1 - a list containing the command to execute.
            e.g.: cmd = ['ls', '/tmp']

        cmd2 - a list containing the command to pipe the output
            of cmd1 to.
            e.g.: cmd = ['grep', 'a_file']

    Returns:

        ret - a dictionary upon return contains the keys:
            'subproc', 'err', 'out'

        ret['subproc'].returncode = subprocess return code
        ret['err'] = command errors string.
        ret['out'] = command out list.

    Example:
        
        cmd1 = ['ls', '/tmp']
        cmd2 = ['grep', 'a_file']
        ret = _run_pipe_cmd(cmd1, cmd2)

        ret.keys()
        ['subproc', 'err', 'out']
        ret['subproc'].returncode
        0
        ret['err']
        ''
        ret['out']

    '''

    # Return dictionary to contain keys: 'cmd', 'subproc', 'err', 'out'
    ret = {'subproc' : None, 'err' : '' , 'out' : ''}

    p1 = None
    p2 = None
    pfail = _run_cmd_return_subproc()

    # Execute the first command:
    try:
        p1 = Popen(cmd1, stdout=PIPE)
        p2 = Popen(cmd2, stdin=p1.stdout, stdout=PIPE )
        p1.stdout.close()

        # fill ret['out'] with stdout and ret['err'] with stderr
        # ret.update(zip(['out', 'err'], ret['subproc'].communicate()[0]))
        ret.update(zip(['out', 'err'], p2.communicate()))
        ret['subproc'] = p2

    # unable to find command will result in an OSError
    except OSError, err:
        if p2:
            ret['subproc'] = p2
        elif p1:
            ret['subproc'] = p1
        else:
            ret['subproc'] = pfail

        ret['subproc'].returncode = 127 # command not found
        ret['err'] = str(err)
        return ret

    return ret

#
# Methods used to parse the CS<->AS text based API
#
def _commond_validate_message(src):
    '''
    Perform validation of the text message sent from the Config Server.
    '''

    if not src.startswith('|') or not src.endswith('|'):
        raise ASError(('Invalid start and end characters: %s') % (src))

def _parse_require_config(src):
    '''
    Description:
        Parse the required config text message sent from the Config Server.

    Input: 
        The required config string obtained from the Config Server.
    The delimiters will be an | and an &

        Two tags will mark the sections of the data. Each tag will be precede
        with an |:

        |classes
        |parameters

        To ensure all the data was received the entire string will be
        terminated with an "|".

        The string "|classes" will precede the class names. I don't think
        the class names need to be base64 encoded.

        The string "|parameters" will precede the parameter parameter
        names&<b64 encoded values>.

    This will be a continuous text string (no CR or New Line).

        Format:

        |classes&<c1>&<c2>...&<cN>
            |parameters|name1&<b64val>|name2&<b64val>...|nameN&<b64v>|

        e.g.:
        |classes&ssh::server&apache2::common
            |parameters|ssh_port&<b64/22>|apache_port&<b64/8081>|

    Returns:
        - a list of classes
        - a name&value list of parameters.
    '''

    _commond_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no required config needed.
        return [''], ['']

    if src.find('|classes') != 0:
        _raise_ASError(('|classes not the first tag found. %s') % (src))

    if src.find('|parameters') <= 0:
        _raise_ASError(('|parameters not found after |classes. %s')
             % (src))

    params_str = src[src.find('|parameters'):len(src)-1]
    classes_str = src[src.find('|classes'):src.find('|parameters')]

    return params_str[len('|parameters')+1:].split('|'), \
        classes_str[len('|classes')+1:].split('&')
        
def generate_yaml(src, yaml_file=PUPPET_YAML_FILE):
    '''
    Description:
        Generate the Puppet input YAML file.
        Uses _parse_require_config()

    Input: 
        The required config string obtained from the Config Server.

        Allow for an alternate puppet YAML file for unit testing.

    Output:
        The Puppet YAML file.
            The YAML file format:
                ---
                parameters: 
                  <p1>: <v1>
                  <p2>: <v2>
                ...
                <pN>: <vN>
                classes: 
                - <name1::type1>
                - <name2::type2>
                ...
                - <nameN::typeN>

            e.g.:
                ---
                parameters: 
                  ssh_port: 22
                  apache_port: 8081
                classes: 
                - ssh::server
                - apache2::common

    Returns:
        False - If the Puppet YAML file was not created. This could happen
                if no required parametes or classes were provided.
        True  - If the Puppet YAML file was created.
    '''
    syslog.syslog('Invoked generate_yaml()')

    params_list, classes_list = _parse_require_config(src)


    # If both classes or parameters are missing treat as no required
    # configuration parameters are needed. Simply return False
    if params_list == [''] and classes_list == ['']:
        return False

    # If both classes or parameters are missing treat as an exception.
    if params_list == [''] or classes_list == ['']:
        _raise_ASError(('Missing classes or parameters. %s') % (src))

    with open(yaml_file, 'w') as yaml_fp:
        yaml_fp.writelines('---\n')
        yaml_fp.writelines('parameters:\n')
        try:
            for param in params_list:
                name_val = param.split('&')
                yaml_fp.writelines('  ' + str(name_val[0]))
                yaml_fp.writelines(': ' + \
                    base64.b64decode(str(name_val[1])) + '\n')
        except IndexError:
            _raise_ASError(('Missing parameter value. %s') % (src))

        yaml_fp.writelines('classes:\n')
        for classes in classes_list:
            yaml_fp.writelines('- ' + str(classes) + '\n')

    return True

def invoke_puppet(yaml_file=PUPPET_YAML_FILE):
    '''
    Description:
        Run the puppet command using the generated Puppet input YAML file.
        Uses _run_pipe_cmd()

    Input: 
        The Puppet input YAML file must exist.

        Allow for an alternate puppet YAML file for unit testing.

    Returns:
        None

    On Failure:
        Raise ASError

    '''
    syslog.syslog('Invoked invoke_puppet()')

    cmd1 = ['/bin/echo']

    cmd2 = ['/usr/bin/puppet', '--verbose', '--manifest', \
        str(PUPPET_ROOT) + '/manifests/defaults.pp', \
        '--modulepath', str(PUPPET_ROOT) + '/modules', \
        '--external_nodes', str(PUPPET_EXT_NODE), \
        '--node_terminus', 'exec', '--no-report', '>>', str(LOG), '2>&1']

    ret = _run_pipe_cmd(cmd1, cmd2)
    if ret['subproc'].returncode != 0:
        _raise_ASError(('Failed Puppet command: %s Error: %s') % \
            (str(cmd2), str(ret)))

def _get_system_info():
    '''
    Description:
        Get the system info to be used for generating this instances
        provides back to the Config Server.

        Currently utilizes Puppet's facter via a Python subprocess call.

    Input: 
        None

    Returns:
        A dictionary of system info name/value pairs.

    '''

    cmd = ['/usr/bin/facter']
    ret = _run_cmd(cmd)
    if ret['subproc'].returncode != 0:
        _raise_ASError(('Failed command: %s Error: %s') % (str(cmd), str(ret)))

    facts = {}
    for fact in ret['out'].split('\n'):
        if fact: # Handle the new line at the end of the facter output
            n, v = fact.split(" => ")
            facts[ n ] = v.rstrip() 

    return facts
     
def _parse_provides_params(src):
    '''
    Description:
        Parse the provides parameters text message sent from the
        Config Server.

    Input: 
        The provides parameters string obtained from the Config Server.

        The delimiters will be an | and an &

        To ensure all the data was received the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Format:
        |name1&name2...&nameN|

        e.g.:
        |ipaddress&virtual|

    Returns:
        - a list of parameter names.
    '''

    _commond_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no provides parameters requested.
        return ['']

    params_str = src[src.find('|')+1:len(src)-1]
 
    return params_str.split('&')
        
def generate_provides(src):
    '''
    Description:
        Generate the provides parameters list.
        Uses _parse_provides_params()

    Input: 
        The provides parameters string obtained from the Config Server.

    Returns:
        A string to send back to the Config Server  with prifix
        'audrey_data='<url encoded return data>'

        The return portion will be delimited with an | and an &

        To ensure all the data is transmitted the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Data portion Format:
        |name1&val1|name2&val...|nameN$valN|

        e.g.:
        |ipaddress&<b64/10.118.46.205>|virtual&<b64/xenu>|

        The return string format:
        "audrey_data=<url encoded data portion>"


    '''
    syslog.syslog('Invoked generate_provides()')

    provides_dict = {}
    params_list = _parse_provides_params(src)

    system_info_dict = _get_system_info()

    for param in params_list:
        try:
            provides_dict.update( \
                {param:base64.b64encode(system_info_dict[param])})
        except KeyError:
            # A specified parameter is not found. Provide value ''
            provides_dict.update({param:''})


    # Create string to send to Config Server
    provides_list = ['']
    for key in provides_dict.keys():
        print str(key) + '&' + str(provides_dict[key])
        provides_list.append(str(key) + '&' + str(provides_dict[key]))
    provides_list.append('')

    return urllib.urlencode({'audrey_data':'|'.join(provides_list)})

#
# Classes and methods to perform the curl get and put to and from
# the Config Server (CS)
#
class CSCurlUnitTest(object):
    '''
    Description:
        When testing the curl object does not exists.
        This class provides methods that could be preformed
        on a real curl class when doing UNITTESTing.
    '''
    def errstr(self):
        return 'UNITTEST - No Errors'

    def getinfo(self, no_param):
        return 'UNITTEST - No Info'

    def setopt(self, no_opt, no_val):
        pass

    def perform(self):
        pass

    def close(self):
        pass

class CSCurl(object):

    '''
    Description:
        Curl interface to Config Server (CS)
    '''

    def __init__(self, UNITTEST =  False):
        '''
        Description:
            Set initial state so it can be tracked. Valuable for
            testing and debugging.
        '''

        self.version = 0
        self.cloud_type = 'UNKNOWN'
        self.cs_addr = ''
        self.cs_port = ''
        self.cs_UUID = ''
        self.ec2_user_data_url = 'http://169.254.169.254/2009-04-04/user-data'
        self.config_serv = ''
        self.cs_params = ''
        self.cs_configs = ''

        #
        # What Cloud Backend?
        #
        # Read the file populated with Cloud back end type.
        # e.g.: CLOUD_TYPE="EC2"
        # NOTE: Currently only EC2 is supported.
        #
        self.cloud_info_file = '/etc/sysconfig/cloud-info'
        if not UNITTEST:
            try:
                with open(self.cloud_info_file, 'r') as f:
                    read_data = f.read()
            except IOError:
                _raise_ASError(('Failed accessing file %s') % \
                    (self.cloud_info_file))
        else:
            read_data = 'UNITTEST'

        #
        # Discover the Config Server access info.
        #
        if 'EC2' in read_data.upper():
            #
            # If on EC2 curl the user data will contain the Config Server
            # access info.
            #
            self.cloud_type = 'EC2'

            try:
                self.curlp = pycurl.Curl()
                self.curlp.setopt(pycurl.HTTPHEADER, ['Accept: text/plain'])
                self.curlp.setopt(pycurl.WRITEFUNCTION, self._get_ec2_user_data)
                self.curlp.setopt(pycurl.FOLLOWLOCATION, 1)
                self.curlp.setopt(pycurl.MAXREDIRS, 5)
                url = self.ec2_user_data_url
                self.curlp.setopt(pycurl.URL, url)
                self.curlp.perform()

                self.cs_addr = self.config_serv.split(':')[0]
                self.cs_port = self.config_serv.split(':')[1]
                self.cs_UUID = self.config_serv.split(':')[2]
            except:
                _raise_ASError('Failed accessing EC2 user data.')

        elif 'UNITTEST' in read_data.upper():
            #
            # For testing from UNITTEST
            # Populate self.cloud_info_file with UNITTEST
            #
            self.cloud_type = 'UNITTEST'
            self.config_serv = 'csAddr:csPort:csUUID'
            self.cs_addr = self.config_serv.split(':')[0]
            self.cs_port = self.config_serv.split(':')[1]
            self.cs_UUID = self.config_serv.split(':')[2]
            self.curlp = CSCurlUnitTest()

        else:
            _raise_ASError(('Unrecognized Cloud Type: %s') % \
                (self.cloud_type))

    def __str__(self):
        '''
        Description:
            Called by the str() function and by the print statement to
            produce the informal string representation of an object.
        '''
        return('<Instance of: %s\n' \
               'Version: %s\n' \
               'EC2 User Data URL: %s\n' \
               'Cloud Type: %s\n' \
               'Config Server: %s\n' \
               'Config Server Addr: %s\n' \
               'Config Server Port: %s\n' \
               'Config Server UUID: %s\n' \
               'Config Server Params: %s\n' \
               'Config Server Configs: %s\n' \
               'eot>' %
            (self.__class__.__name__,
            str(self.version),
            str(self.ec2_user_data_url),
            str(self.cloud_type),
            str(self.config_serv),
            str(self.cs_addr),
            str(self.cs_port),
            str(self.cs_UUID),
            str(self.cs_params),
            str(self.cs_configs)))

    #
    # Pycurl Callbacks:
    # These callback methods will be specified as a pycurl.WRITEFUNCTION
    # Which pycurl will then invoke with returned data to write.
    #
    def _get_ec2_user_data(self, buf):
        '''
        Description:
            pycurl call back for ec2 user data

            The EC2 User data contains the b64 encoded Config Server
            access info.
        '''
        self.config_serv = base64.b64decode(buf)

    def _get_cs_configs_CB(self, buf):
        '''
        Description:
            pycurl call back for get_cs_configs
        '''
        self.cs_configs = buf

    def _get_cs_params_CB(self, buf):
        '''
        Description:
            pycurl call back for get_cs_params
        '''
        self.cs_params = buf

    # Public interfaces
    def get_cs_configs(self):
        '''
        Description:
            Curl get the required configuration from the Config Server.
        '''
        syslog.syslog('Invoked CSCurl.get_cs_configs()')

        self.curlp.setopt(pycurl.WRITEFUNCTION, self._get_cs_configs_CB)

        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/configs/' + str(self.version) + '/' + self.cs_UUID

        self.curlp.setopt(pycurl.URL, url)
        self.curlp.perform()

        return self.cs_configs

    def get_cs_params(self):
        '''
        Description:
            Curl get the provides parameters from the Config Server.
        '''
        syslog.syslog('Invoked CSCurl.get_cs_params()')

        self.curlp.setopt(pycurl.WRITEFUNCTION, self._get_cs_params_CB)

        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/params/' + str(self.version) + '/' + self.cs_UUID

        self.curlp.setopt(pycurl.URL, url)
        self.curlp.perform()

        return self.cs_params

    def put_cs_params_values(self, params_values):
        '''
        Description:
            Curl put the provides parameters to the Config Server.
        '''
        syslog.syslog('Invoked CSCurl.put_cs_params_values()')

        url = 'http://' + self.cs_addr + ':' + self.cs_port + \
            '/params/' + str(self.version) + '/' + self.cs_UUID

        params_values_str = ['"', params_values, '"']

        cmd = ['/usr/bin/curl', '-X', 'PUT', '-w', \
            '"HTTP_CODE: %{http_code}\n"', '-d',
            params_values, url ]

        ret = _run_cmd(cmd)
        if ret['subproc'].returncode != 0:
            _raise_ASError(('Failed command: %s Error: %s') % \
                (str(cmd), str(ret)))


    def close_cs(self):
        '''
        Description:
            Close the curl pointer open by _init()
        '''
        syslog.syslog('Invoked CSCurl.close_cs()')

        self.curlp.close()

def audrey_script_main():
    '''
    Description:
        This script will be used on EC2 for configuring the running
        instance based on Cloud Engine configuration supplied at
        launch time in the user data.

    '''
    syslog.syslog('Invoked CSCurl.close_cs()')

    finished = False

    while not finished:

        # Create the Curl Object
        cs_curl = CSCurl()

        # Curl/Get the Required Configs from the Config Server
        configs = cs_curl.get_cs_configs()

        # Generate the YAML file using the provided required configs
        generate_yaml(configs)

        # Exercise Puppet using the generated YAML
        #
        # Exercise puppet to configure the system using the user
        # specified puppet input.
        #
        invoke_puppet()

        # Curl/Get the requested provides from the Config Server
        params = cs_curl.get_cs_params()

        # Generate the values for the requested provides parameters.
        params_values = generate_provides(params)

        # Curl/Put the requested provides with values to the Config Server
        cs_curl.put_cs_params_values(params_values)

        #
        # Eventually this loop will be repeated until the Config Server
        # indiactes all "requres" and "profides" have been exchanged. For
        # now the Config Server is coded to only support/require 1 pass
        finished = True


if __name__ == '__main__':

    audrey_script_main()


