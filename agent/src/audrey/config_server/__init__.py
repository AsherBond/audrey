'''
*
*   Copyright [2011] [Red Hat, Inc.]
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*  limitations under the License.
*
'''

import os
import logging
import base64
import urllib

from collections import deque

from audrey import ASError
from audrey.config_server.service import ServiceParams
from audrey.shell import run_cmd
from audrey.shell import get_system_info

logger = logging.getLogger('Audrey')

#
# Methods used to parse the CS<->AS text based API
#
def _common_validate_message(src):
    '''
    Perform validation of the text message sent from the Config Server.
    '''

    if not src.startswith('|') or not src.endswith('|'):
        raise ASError(('Invalid start and end characters: %s') % (src))

def gen_env(serv_name, param_val):
    '''
    Description:
        Generate the os environment variables from the required config string.

    Input:
        serv_name - A service name
            e.g.:
            jon_agent_config

        param_val - A parameter name&val pair. The value is base64 encoded.
            e.g.:
            jon_server_ip&MTkyLjE2OC4wLjE=

    Output:
        Set environment variables of the form:
        <name>=<value>
            e.g.:
            jon_server_ip=base64.b64decode('MTkyLjE2OC4wLjE=')
            jon_server_ip='192.168.0.1

    Raises ASError when encountering an error.

    '''
    logger.debug('Invoked gen_env()')

    # If the param_val is missing treat as an exception.
    if param_val == '':
        raise ASError(('Missing parameter name. %s') % \
            (str(param_val)))

    # If serv_name is not blank an extra "_" must be added to
    # the environment variable name.
    if serv_name != '':
        serv_name = serv_name + '_'

    name_val = param_val.split('&')
    var_name = 'AUDREY_VAR_' + serv_name + name_val[0]
    os.environ[var_name] = \
        base64.b64decode(name_val[1])

    # Get what was set and log it.
    cmd = ['/usr/bin/printenv', var_name]
    ret = run_cmd(cmd)
    logger.debug(var_name + '=' + str(ret['out'].strip()))

def parse_require_config(src):
    '''
    Description:
        Parse the required config text message sent from the Config Server.

    Input:
        The required config string obtained from the Config Server,
        delimited by an | and an &

        Two tags will mark the sections of the data,
        '|service|' and  '|parameters|'

        To ensure all the data was received the entire string will be
        terminated with an "|".

        The string "|service|" will precede a service names.

        The string "|parameters|" will precede the parameters for
        the preceeding service, in the form: names&<b64 encoded values>.

    This will be a continuous text string (no CR or New Line).

        Format (repeating for each service):

        |service|<s1>|parameters|name1&<b64val>|name2&<b64val>...|nameN&<b64v>|


        e.g.:
        |service|ssh::server|parameters|ssh_port&<b64('22')>
        |service|apache2::common|apache_port&<b64('8081')>|

    Returns:
        - A list of ServiceParams objects.
    '''

    services = []
    new = None

    _common_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no required config needed.
        return []

    if src.find('|service|') != 0:
        raise ASError(('|service| is not the first tag found. %s') % (src))


    src_q = deque(src.split('|'))

    # remove leading and trailing elements from the src_q since they are
    # empty strings generated by the split('|') because of the leading
    # and trailing '|'
    token = src_q.popleft()
    token = src_q.pop()

    while True:
        try:
            token = src_q.popleft()
            if token == 'service':
                token = src_q.popleft() # next token is service name

                # Raise an error if the service name is invalid.
                if token.find('&') != -1 or \
                    token == 'service' or \
                    token == 'parameters':
                    raise ASError(('ERROR invalid service name: %s') % \
                       (str(token)))

                new = ServiceParams(token)
                services.append(new)
            elif token == 'parameters' or token == '':
                pass
            else: # token is a name&value pair.
                if token.find('&') == -1:
                    raise ASError(('ERROR name&val: %s missing delimiter') % \
                       (str(token)))
                if new:
                    new.add_param(token)
                    gen_env(new.name, token)
                else:
                    raise ASError(('ERROR missing service tag %s') % \
                         (str(src)))
        except IndexError:
            break

    return services

def parse_provides_params(src):
    '''
    Description:
        Parse the provides parameters text message sent from the
        Config Server.

    Input:
        The provides parameters string obtained from the Config Server.

        The delimiters will be an | and an &

        To ensure all the data was received the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Format:
        |name1&name2...&nameN|

        e.g.:
        |ipaddress&virtual|

    Returns:
        - a list of parameter names.
    '''

    _common_validate_message(src)

    # Message specific validation
    if src == '||':
        # special case indicating no provides parameters requested.
        return ['']

    params_str = src[src.find('|')+1:len(src)-1]

    return params_str.split('&')

def generate_provides(src):
    '''
    Description:
        Generate the provides parameters list.
        Uses parse_provides_params()

    Input:
        The provides parameters string obtained from the Config Server.

    Returns:
        A string to send back to the Config Server  with prifix
        'audrey_data='<url encoded return data>'

        The return portion will be delimited with an | and an &

        To ensure all the data is transmitted the entire string will be
        terminated with an "|".

        This will be a continuous text string (no CR or New Line).

        Data portion Format:
        |name1&val1|name2&val...|nameN$valN|

        e.g.:
        |ipaddress&<b64/10.118.46.205>|virtual&<b64/xenu>|

        The return string format:
        "audrey_data=<url encoded data portion>"


    '''
    logger.info('Invoked generate_provides()')

    provides_dict = {}
    params_list = parse_provides_params(src)

    system_info_dict = get_system_info()

    for param in params_list:
        try:
            provides_dict.update( \
                {param:base64.b64encode(system_info_dict[param])})
        except KeyError:
            # A specified parameter is not found. Provide value ''
            provides_dict.update({param:''})


    # Create string to send to Config Server
    provides_list = ['']
    for key in provides_dict.keys():
        provides_list.append(str(key) + '&' + str(provides_dict[key]))
    provides_list.append('')

    return urllib.urlencode({'audrey_data':'|'.join(provides_list)})
