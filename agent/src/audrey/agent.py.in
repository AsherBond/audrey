'''
*
*   Copyright [2011] [Red Hat, Inc.]
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*  limitations under the License.
*
'''

'''
Audrey Startup (AS)

Note: The source file is named audrey_start.in.py The make process generates
      audrey_start.py. audrey_start.py should not be manually modified.

Invoked at instance launch to interface with the Config Server (CS)

For prototype end to end testing this file needs to be installed
at: /usr/bin/audrey

Algorithim:
    Get CF info
    Loop:
        Get and validate required configuration from CS
        Configure system using required configuration
        Get and validate provides parameters from CS
        Gather provided parameter data from system
        Put provided parameter data to CS
    if not done then goto Loop

'''

import sys
import argparse
import logging

from time import sleep

from audrey import ASError
from audrey import user_data
from audrey.config_server.client import CSClient
from audrey.config_server.tooling import ConfigTooling
from audrey.config_server import parse_require_config
from audrey.config_server import generate_provides
from audrey import setup_logging

SLEEP_SECS = 10
VERSION_URL = 'version'

logger = logging.getLogger('Audrey')

# The VERSION string is filled in during the make process.
AUDREY_VER = '@VERSION@'

def parse_args():
    '''
    Description:
        Gather any Config Server access info optionally passed
        on the command line. If being provided on the command
        line all of it must be provided.

        oAuth Secret is prompted for and not allowed as an argument.
        This is to avoid a ps on the system from displaying the
        oAuth Secret argument.

    Return:
        dict - of parser keys and values
    '''
    desc_txt = 'The Aeolus Audrey Startup Agent, a script which ' + \
               'runs on a booting cloud instance to retrieve ' + \
               'configuration data from the Aeolus Config Server.'

    log_level_dict={'DEBUG' : logging.DEBUG,
        'INFO' : logging.INFO,
        'WARNING' : logging.WARNING,
        'ERROR' : logging.ERROR,
        'CRITICAL' : logging.CRITICAL}

    parser = argparse.ArgumentParser(description=desc_txt)
    parser.add_argument('-e', '--endpoint', dest='endpoint',
        required=False, help='Config Server endpoint url')
    parser.add_argument('-k', '--key', dest='oauth_key', required=False,
        help='oAuth Key. If specified prompt for the oAuth Secret.')
    parser.add_argument('-p', '--pwd', action='store_true', default=False,
        required=False, help='Log and look for configs in pwd',)
    parser.add_argument('-L', '--log-level', dest='log_level',
        required=False, default='INFO', help='Audrey Agent Logging Level',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']),
    parser.add_argument('-V', '-v', '--version', dest='version',
        action='store_true', default=False, required=False,
        help='Displays the program\'s version number and exit.')

    args = parser.parse_args()
    args.log_level = log_level_dict[args.log_level]

    if args.version:
        print AUDREY_VER
        sys.exit()

    if args.oauth_key:
        # Prompt for oAuth secret so ps won't display it.
        args.oauth_secret = raw_input('oAuth Secret: ')

    return args

def main():
    '''
    Description:
        This script will be used on EC2 for configuring the running
        instance based on Cloud Engine configuration supplied at
        launch time in the user data.

        Config Server Status:
        200 HTTP OK - Success and no more data of this type
        202 HTTP Accepted - Success and more data of this type
        404 HTTP Not Found - This may be temporary so try again
    '''
    # parse the args and setup logging
    conf = parse_args()
    log_file = {}
    tool_dir = {}
    if 'pwd' in conf and conf.pwd:
        log_file = { 'logfile_name': 'audrey.log' }
        tool_dir = { 'tool_dir': 'tooling' }

    setup_logging(level=conf.log_level, **log_file)

    if not conf.endpoint:
        # discover the cloud I'm on
        conf = user_data.discover().read()

    # ensure the conf is a dictionary, not a namespace
    if hasattr(conf, '__dict__'):
        conf = vars(conf)

    logger.info('Invoked audrey main')

    # 0 means don't run again
    # -1 is non zero so initial runs will happen
    config_status = -1
    param_status = -1
    tooling_status = -1

    max_retry = 5
    services = []

    # Create the Client Object
    cs_client = CSClient(**conf)
    # test connectivity, try and wait for it if it's not there
    url = cs_client._cs_url(VERSION_URL)
    while isinstance(cs_client._get(url)[0], Exception):
        if max_retry:
            max_retry-=1
            logger.info('Failed attempt to contact config server')
            sleep(SLEEP_SECS)
        else:
            logger.error('Failed to connect to the Configserver')
            exit(1)

    max_retry = 5

    logger.info(str(cs_client))

    logger.debug('Get optional tooling from the Config Server')
    # Get any optional tooling from the Config Server
    tooling = ConfigTooling(**tool_dir)
    tooling_status, tarball = cs_client.get_cs_tooling()
    if tooling_status == 200 or tooling_status == 202:
        tooling.unpack_tooling(tarball)
    else:
        logger.info('No optional config tooling provided. status: ' + \
                str(tooling_status))
    logger.debug(str(tooling))

    logger.debug('Process the Requires and Provides parameters')

    # Process the Requires and Provides parameters until the HTTP status
    # from the get_cs_configs and the get_cs_params both return 200
    while config_status or param_status:

        logger.debug('Config Parameter status: ' + str(config_status))
        logger.debug('Return Parameter status: ' + str(param_status))

        # Get the Required Configs from the Config Server
        if config_status:
            config_status, configs = cs_client.get_cs_configs()

            # Configure the system with the provided Required Configs
            if config_status == 200:
                services = parse_require_config(configs)
                tooling.invoke_tooling(services)
                # don't do any more config status work
                # now that the tooling has run
                config_status = 0
            else:
                logger.info('No configuration parameters provided. status: ' + \
                    str(config_status))

        # Get the requested provides from the Config Server
        if param_status:
            get_status, params = cs_client.get_cs_params()

            # Gather the values from the system for the requested provides
            if get_status == 200:
                params_values = generate_provides(params)
            else:
                params_values = '||'

            # Put the requested provides with values to the Config Server
            param_status, body = cs_client.put_cs_params_values(params_values)
            if param_status == 200:
                # don't operate on params anymore, all have been provided.
                param_status = 0

        # Retry a number of times if 404 HTTP Not Found is returned.
        if config_status == 404 or param_status == 404:
            logger.error('Requiest to Config Server failed or more to come.')
            logger.error('Required Config Parameter status: ' + \
                str(config_status))
            logger.info('Return Parameter status: ' + str(param_status))

            max_retry -= 1
            if max_retry < 0:
                raise ASError('Too many erroneous Config Server responses.')

        sleep(SLEEP_SECS)
